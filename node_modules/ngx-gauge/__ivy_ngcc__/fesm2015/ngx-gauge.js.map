{"version":3,"sources":["C:/Users/Ashish Chopra/Desktop/github/ngx-gauge/dist/ngx-gauge/fesm2015/ngx-gauge.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsCC,mBAMC;;;;;;;;;;CAED,mBAMC;;;;;;;;;;CAED,mBAMC;;;;;;;;;;CAED,mBAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiYD,aAkBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0HD,0KAOC","file":"ngx-gauge.js","sourcesContent":["import { Directive, Component, ViewEncapsulation, ElementRef, Renderer, ViewChild, ContentChild, Input, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @param {?} value\r\n * @param {?} min\r\n * @param {?} max\r\n * @return {?}\r\n */\r\nfunction clamp(value, min, max) {\r\n    return Math.max(min, Math.min(max, value));\r\n}\r\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction coerceBooleanProperty(value) {\r\n    return value != null && `${value}` !== 'false';\r\n}\r\n/**\r\n * @param {?} value\r\n * @param {?=} fallbackValue\r\n * @return {?}\r\n */\r\nfunction coerceNumberProperty(value, fallbackValue = 0) {\r\n    return isNaN(parseFloat(value)) || isNaN(Number(value)) ? fallbackValue : Number(value);\r\n}\r\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction cssUnit(value) {\r\n    return `${value}px`;\r\n}\r\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isNumber(value) {\r\n    return value != undefined && !isNaN(parseFloat(value)) && !isNaN(Number(value));\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass NgxGaugeAppend {\r\n}\r\nNgxGaugeAppend.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: \"ngx-gauge-append\",\r\n                exportAs: \"ngxGaugeAppend\"\r\n            },] }\r\n];\r\nclass NgxGaugePrepend {\r\n}\r\nNgxGaugePrepend.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: \"ngx-gauge-prepend\",\r\n                exportAs: \"ngxGaugePrepend\"\r\n            },] }\r\n];\r\nclass NgxGaugeValue {\r\n}\r\nNgxGaugeValue.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: \"ngx-gauge-value\",\r\n                exportAs: \"ngxGaugeValue\"\r\n            },] }\r\n];\r\nclass NgxGaugeLabel {\r\n}\r\nNgxGaugeLabel.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: \"ngx-gauge-label\",\r\n                exportAs: \"ngxGaugeLabel\"\r\n            },] }\r\n];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst DEFAULTS = {\r\n    MIN: 0,\r\n    MAX: 100,\r\n    TYPE: 'arch',\r\n    THICK: 4,\r\n    FOREGROUND_COLOR: 'rgba(0, 150, 136, 1)',\r\n    BACKGROUND_COLOR: 'rgba(0, 0, 0, 0.1)',\r\n    CAP: 'butt',\r\n    SIZE: 200\r\n};\r\nclass NgxGauge {\r\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?} _renderer\r\n     */\r\n    constructor(_elementRef, _renderer) {\r\n        this._elementRef = _elementRef;\r\n        this._renderer = _renderer;\r\n        this._size = DEFAULTS.SIZE;\r\n        this._min = DEFAULTS.MIN;\r\n        this._max = DEFAULTS.MAX;\r\n        this._animate = true;\r\n        this._initialized = false;\r\n        this._animationRequestID = 0;\r\n        this.ariaLabel = '';\r\n        this.ariaLabelledby = null;\r\n        this.type = (/** @type {?} */ (DEFAULTS.TYPE));\r\n        this.cap = (/** @type {?} */ (DEFAULTS.CAP));\r\n        this.thick = DEFAULTS.THICK;\r\n        this.foregroundColor = DEFAULTS.FOREGROUND_COLOR;\r\n        this.backgroundColor = DEFAULTS.BACKGROUND_COLOR;\r\n        this.thresholds = Object.create(null);\r\n        this._value = 0;\r\n        this.duration = 1200;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get size() { return this._size; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set size(value) {\r\n        this._size = coerceNumberProperty(value);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get min() { return this._min; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set min(value) {\r\n        this._min = coerceNumberProperty(value, DEFAULTS.MIN);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get animate() { return this._animate; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set animate(value) {\r\n        this._animate = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get max() { return this._max; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set max(value) {\r\n        this._max = coerceNumberProperty(value, DEFAULTS.MAX);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get value() { return this._value; }\r\n    /**\r\n     * @param {?} val\r\n     * @return {?}\r\n     */\r\n    set value(val) {\r\n        this._value = coerceNumberProperty(val);\r\n    }\r\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    ngOnChanges(changes) {\r\n        /** @type {?} */\r\n        const isCanvasPropertyChanged = changes['thick'] || changes['type'] || changes['cap'] || changes['size'];\r\n        /** @type {?} */\r\n        const isDataChanged = changes['value'] || changes['min'] || changes['max'];\r\n        if (this._initialized) {\r\n            if (isDataChanged) {\r\n                /** @type {?} */\r\n                let nv;\r\n                /** @type {?} */\r\n                let ov;\r\n                if (changes['value']) {\r\n                    nv = changes['value'].currentValue;\r\n                    ov = changes['value'].previousValue;\r\n                }\r\n                this._update(nv, ov);\r\n            }\r\n            if (isCanvasPropertyChanged) {\r\n                this._destroy();\r\n                this._init();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _updateSize() {\r\n        this._renderer.setElementStyle(this._elementRef.nativeElement, 'width', cssUnit(this._size));\r\n        this._renderer.setElementStyle(this._elementRef.nativeElement, 'height', cssUnit(this._size));\r\n        this._canvas.nativeElement.width = this.size;\r\n        this._canvas.nativeElement.height = this.size;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterViewInit() {\r\n        if (this._canvas) {\r\n            this._init();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._destroy();\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} type\r\n     * @return {?}\r\n     */\r\n    _getBounds(type) {\r\n        /** @type {?} */\r\n        let head;\r\n        /** @type {?} */\r\n        let tail;\r\n        if (type == 'semi') {\r\n            head = Math.PI;\r\n            tail = 2 * Math.PI;\r\n        }\r\n        else if (type == 'full') {\r\n            head = 1.5 * Math.PI;\r\n            tail = 3.5 * Math.PI;\r\n        }\r\n        else if (type === 'arch') {\r\n            head = 0.8 * Math.PI;\r\n            tail = 2.2 * Math.PI;\r\n        }\r\n        return { head, tail };\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} start\r\n     * @param {?} middle\r\n     * @param {?} tail\r\n     * @param {?} color\r\n     * @return {?}\r\n     */\r\n    _drawShell(start, middle, tail, color) {\r\n        /** @type {?} */\r\n        let center = this._getCenter();\r\n        /** @type {?} */\r\n        let radius = this._getRadius();\r\n        middle = Math.max(middle, start); // never below 0%\r\n        middle = Math.min(middle, tail); // never exceed 100%\r\n        if (this._initialized) {\r\n            this._clear();\r\n            this._context.beginPath();\r\n            this._context.strokeStyle = this.backgroundColor;\r\n            this._context.arc(center.x, center.y, radius, middle, tail, false);\r\n            this._context.stroke();\r\n            this._context.beginPath();\r\n            this._context.strokeStyle = color;\r\n            this._context.arc(center.x, center.y, radius, start, middle, false);\r\n            this._context.stroke();\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _clear() {\r\n        this._context.clearRect(0, 0, this._getWidth(), this._getHeight());\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getWidth() {\r\n        return this.size;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getHeight() {\r\n        return this.size;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getRadius() {\r\n        /** @type {?} */\r\n        var center = this._getCenter();\r\n        return center.x - this.thick;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _getCenter() {\r\n        /** @type {?} */\r\n        var x = this._getWidth() / 2;\r\n        /** @type {?} */\r\n        var y = this._getHeight() / 2;\r\n        return { x, y };\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _init() {\r\n        this._context = ((/** @type {?} */ (this._canvas.nativeElement))).getContext('2d');\r\n        this._initialized = true;\r\n        this._updateSize();\r\n        this._setupStyles();\r\n        this._create();\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _destroy() {\r\n        if (this._animationRequestID) {\r\n            window.cancelAnimationFrame(this._animationRequestID);\r\n            this._animationRequestID = 0;\r\n        }\r\n        this._clear();\r\n        this._context = null;\r\n        this._initialized = false;\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    _setupStyles() {\r\n        this._context.lineCap = this.cap;\r\n        this._context.lineWidth = this.thick;\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    _getForegroundColorByRange(value) {\r\n        /** @type {?} */\r\n        const match = Object.keys(this.thresholds)\r\n            .filter((/**\r\n         * @param {?} item\r\n         * @return {?}\r\n         */\r\n        function (item) { return isNumber(item) && Number(item) <= value; }))\r\n            .sort((/**\r\n         * @param {?} a\r\n         * @param {?} b\r\n         * @return {?}\r\n         */\r\n        (a, b) => Number(a) - Number(b)))\r\n            .reverse()[0];\r\n        return match !== undefined\r\n            ? this.thresholds[match].color || this.foregroundColor\r\n            : this.foregroundColor;\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?=} nv\r\n     * @param {?=} ov\r\n     * @return {?}\r\n     */\r\n    _create(nv, ov) {\r\n        /** @type {?} */\r\n        let self = this;\r\n        /** @type {?} */\r\n        let type = this.type;\r\n        /** @type {?} */\r\n        let bounds = this._getBounds(type);\r\n        /** @type {?} */\r\n        let duration = this.duration;\r\n        /** @type {?} */\r\n        let min = this.min;\r\n        /** @type {?} */\r\n        let max = this.max;\r\n        /** @type {?} */\r\n        let value = clamp(this.value, this.min, this.max);\r\n        /** @type {?} */\r\n        let start = bounds.head;\r\n        /** @type {?} */\r\n        let unit = (bounds.tail - bounds.head) / (max - min);\r\n        /** @type {?} */\r\n        let displacement = unit * (value - min);\r\n        /** @type {?} */\r\n        let tail = bounds.tail;\r\n        /** @type {?} */\r\n        let color = this._getForegroundColorByRange(value);\r\n        /** @type {?} */\r\n        let startTime;\r\n        if (self._animationRequestID) {\r\n            window.cancelAnimationFrame(self._animationRequestID);\r\n        }\r\n        /**\r\n         * @param {?} timestamp\r\n         * @return {?}\r\n         */\r\n        function animate(timestamp) {\r\n            timestamp = timestamp || new Date().getTime();\r\n            /** @type {?} */\r\n            let runtime = timestamp - startTime;\r\n            /** @type {?} */\r\n            let progress = Math.min(runtime / duration, 1);\r\n            /** @type {?} */\r\n            let previousProgress = ov ? (ov - min) * unit : 0;\r\n            /** @type {?} */\r\n            let middle = start + previousProgress + displacement * progress;\r\n            self._drawShell(start, middle, tail, color);\r\n            if (self._animationRequestID && (runtime < duration)) {\r\n                self._animationRequestID = window.requestAnimationFrame((/**\r\n                 * @param {?} timestamp\r\n                 * @return {?}\r\n                 */\r\n                (timestamp) => animate(timestamp)));\r\n            }\r\n            else {\r\n                window.cancelAnimationFrame(self._animationRequestID);\r\n            }\r\n        }\r\n        if (this._animate) {\r\n            if (nv != undefined && ov != undefined) {\r\n                displacement = unit * nv - unit * ov;\r\n            }\r\n            self._animationRequestID = window.requestAnimationFrame((/**\r\n             * @param {?} timestamp\r\n             * @return {?}\r\n             */\r\n            (timestamp) => {\r\n                startTime = timestamp || new Date().getTime();\r\n                animate(startTime);\r\n            }));\r\n        }\r\n        else {\r\n            self._drawShell(start, start + displacement, tail, color);\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} nv\r\n     * @param {?} ov\r\n     * @return {?}\r\n     */\r\n    _update(nv, ov) {\r\n        this._clear();\r\n        this._create(nv, ov);\r\n    }\r\n}\r\nNgxGauge.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'ngx-gauge',\r\n                template: \"<div class=\\\"reading-block\\\" #reading [style.fontSize]=\\\"size * 0.22 + 'px'\\\" [style.lineHeight]=\\\"size + 'px'\\\">\\r\\n  <!-- This block can not be indented correctly, because line breaks cause layout spacing, related problem: https://pt.stackoverflow.com/q/276760/2998 -->\\r\\n  <u class=\\\"reading-affix\\\" [ngSwitch]=\\\"_prependChild != null\\\"><ng-content select=\\\"ngx-gauge-prepend\\\" *ngSwitchCase=\\\"true\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{prepend}}</ng-container></u><ng-container [ngSwitch]=\\\"_valueDisplayChild != null\\\"><ng-content *ngSwitchCase=\\\"true\\\" select=\\\"ngx-gauge-value\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{value | number}}</ng-container></ng-container><u class=\\\"reading-affix\\\" [ngSwitch]=\\\"_appendChild != null\\\"><ng-content select=\\\"ngx-gauge-append\\\" *ngSwitchCase=\\\"true\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{append}}</ng-container></u>\\r\\n</div>\\r\\n<div class=\\\"reading-label\\\" \\r\\n     [style.fontSize]=\\\"size / 13 + 'px'\\\" \\r\\n     [style.lineHeight]=\\\"(5 * size / 13) + size + 'px'\\\" \\r\\n     [ngSwitch]=\\\"_labelChild != null\\\">\\r\\n  <ng-content select=\\\"ngx-gauge-label\\\" *ngSwitchCase=\\\"true\\\"></ng-content>\\r\\n  <ng-container *ngSwitchCase=\\\"false\\\">{{label}}</ng-container>\\r\\n</div>\\r\\n<canvas #canvas></canvas>\",\r\n                host: {\r\n                    'role': 'slider',\r\n                    'aria-readonly': 'true',\r\n                    '[class.ngx-gauge-meter]': 'true',\r\n                    '[attr.aria-valuemin]': 'min',\r\n                    '[attr.aria-valuemax]': 'max',\r\n                    '[attr.aria-valuenow]': 'value',\r\n                    '[attr.aria-label]': 'ariaLabel',\r\n                    '[attr.aria-labelledby]': 'ariaLabelledby'\r\n                },\r\n                encapsulation: ViewEncapsulation.None,\r\n                styles: [\".ngx-gauge-meter{display:inline-block;text-align:center;position:relative}.reading-block{position:absolute;width:100%;font-weight:400;white-space:nowrap;text-align:center;overflow:hidden;text-overflow:ellipsis}.reading-label{font-family:inherit;width:100%;display:inline-block;position:absolute;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:400}.reading-affix{text-decoration:none;font-size:.6em;opacity:.8;font-weight:200;padding:0 .18em}.reading-affix:first-child{padding-left:0}.reading-affix:last-child{padding-right:0}\"]\r\n            }] }\r\n];\r\n/** @nocollapse */\r\nNgxGauge.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: Renderer }\r\n];\r\nNgxGauge.propDecorators = {\r\n    _canvas: [{ type: ViewChild, args: ['canvas', { static: true },] }],\r\n    _labelChild: [{ type: ContentChild, args: [NgxGaugeLabel, { static: false },] }],\r\n    _prependChild: [{ type: ContentChild, args: [NgxGaugePrepend, { static: false },] }],\r\n    _appendChild: [{ type: ContentChild, args: [NgxGaugeAppend, { static: false },] }],\r\n    _valueDisplayChild: [{ type: ContentChild, args: [NgxGaugeValue, { static: false },] }],\r\n    ariaLabel: [{ type: Input, args: ['aria-label',] }],\r\n    ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }],\r\n    size: [{ type: Input }],\r\n    min: [{ type: Input }],\r\n    animate: [{ type: Input }],\r\n    max: [{ type: Input }],\r\n    type: [{ type: Input }],\r\n    cap: [{ type: Input }],\r\n    thick: [{ type: Input }],\r\n    label: [{ type: Input }],\r\n    append: [{ type: Input }],\r\n    prepend: [{ type: Input }],\r\n    foregroundColor: [{ type: Input }],\r\n    backgroundColor: [{ type: Input }],\r\n    thresholds: [{ type: Input }],\r\n    value: [{ type: Input }],\r\n    duration: [{ type: Input }]\r\n};\r\nif (false) {\r\n    /** @type {?} */\r\n    NgxGauge.prototype._canvas;\r\n    /** @type {?} */\r\n    NgxGauge.prototype._labelChild;\r\n    /** @type {?} */\r\n    NgxGauge.prototype._prependChild;\r\n    /** @type {?} */\r\n    NgxGauge.prototype._appendChild;\r\n    /** @type {?} */\r\n    NgxGauge.prototype._valueDisplayChild;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxGauge.prototype._size;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxGauge.prototype._min;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxGauge.prototype._max;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxGauge.prototype._animate;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxGauge.prototype._initialized;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxGauge.prototype._context;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxGauge.prototype._animationRequestID;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.ariaLabel;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.ariaLabelledby;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.type;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.cap;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.thick;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.label;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.append;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.prepend;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.foregroundColor;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.backgroundColor;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.thresholds;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxGauge.prototype._value;\r\n    /** @type {?} */\r\n    NgxGauge.prototype.duration;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxGauge.prototype._elementRef;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxGauge.prototype._renderer;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass NgxGaugeModule {\r\n}\r\nNgxGaugeModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [CommonModule],\r\n                declarations: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel],\r\n                exports: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel]\r\n            },] }\r\n];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nexport { NgxGaugeModule, NgxGauge as ɵa, NgxGaugeAppend as ɵb, NgxGaugePrepend as ɵc, NgxGaugeValue as ɵd, NgxGaugeLabel as ɵe };\n"]}